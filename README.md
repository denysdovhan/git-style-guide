# Керівництво по розробки з Git (Git Style Guide)

Це керівництво по розробці з Git навіяне статтею [*Як додати свої зміни в ядро Linux*](https://www.kernel.org/doc/Documentation/SubmittingPatches) (*How to Get Your Change Into the Linux Kernel*), інформацією з [сторінок довідки git](http://git-scm.com/doc) та інших практик, які популярні серед спільноти.

Переклади керівництва доступні на таких мовах:

* [Англійська](https://github.com/agis-/git-style-guide)
* [Китайська (Спрощена)](https://github.com/aseaday/git-style-guide)
* [Китайська (Традиційна)](https://github.com/JuanitoFatas/git-style-guide)
* [Японська](https://github.com/objectx/git-style-guide)
* [Корейська](https://github.com/ikaruce/git-style-guide)
* [Португальська](https://github.com/guylhermetabosa/git-style-guide)

Якщо хочете зробити переклад, зробіть його! Форкніть проект та відкрийте pull-request!

# Зміст

1. [Гілки](#%D0%93%D1%96%D0%BB%D0%BA%D0%B8)
2. [Коміти](#Коміти)
  1. [Повідомлення](#Повідомлення)
3. [Злиття](#Злиття)
4. [Інше.](#Інше)

## Гілки

* Оберіть *коротке* та *змістовне* ім’я:

  ```shell
  # добре
  $ git checkout -b oauth-migration

  # погано - надто абстрактно
  $ git checkout -b login_fix
  ```

* Ідентифікатори завдань із зовнішніх сервісів (напр. GitHub
  Issue) добре підійдуть в якості назв для гілок. Наприклад:

  ```shell
  # GitHub issue #15
  $ git checkout -b issue-15
  ```

* Використовуйте *дефіс* в якості роздільника слів.

* Коли кілька людей працюють над *тим самим* функціоналом, буде зручно, якщо
  кожен матиме власну *персональну* гілку та одну *спільну* гілку.
  Використовуйте таке найменування:

  ```shell
  $ git checkout -b feature-a/master # спільна гілка
  $ git checkout -b feature-a/maria  # Персональна гілка Марії
  $ git checkout -b feature-a/nick   # Персональна гілка Ніка
  ```

  Зливайте зміни з *персональних* гілок в одну *спільну* гліку (див. ["Злиття"](#злиття)).
  Зрештою, спільна гілка буде злита з "master".

* Видаляйте ваші гілки з репозиторію після того, як вони були злиті (якщо
  немає важливої причини, аби цього не робити).

  Порада: Використовуйте команду нижче перебуваючи в "master", щоб вивести злиті гілки:

  ```shell
  $ git branch --merged | grep -v "\*"
  ```

## Коміти

* Кожен коміт повинен містити одну *логічну зміну*. Не робіть кілька
  *логічних змін* в одному коміті. Наприклад, якщо ваш патч виправляє помилку
  та покращує продуктивність, то краще розбити його на два коміти.

* Не розділяйте одну *логічну зміну* на кілька комітів. Наприклад,
  реалізація нового функціоналу, та покриття цього функціоналу тестами повинні
  бути в одному коміті.

* Комітьте *своєчасно* та *часто*. Маленькі, атомарні коміти легше зрозуміти
  та відмінити, якщо щось піде не так як слід.

* Коміти повинні бути *логічно* впорядковані. Наприклад, якщо *коміт X*
  залежить від зміни в *коміті Y*, тоді *коміт Y* повинен бути перед *комітом X*.

### Повідомлення

* Для написання повідомлень використовуйте текстовий редактор замість, замість
  терміналу:

  ```shell
  # добре
  $ git commit

  # погано
  $ git commit -m "Quick fix"
  ```

  Написання повідомленнь в терміналі змушують писати повідомлення не більш
  одного рядка, що зазвичай виливається в неінформативні та неоднозначні
  коміти.

* Підсумковий рядок (тобто перший рядок повідомлення) повинен бути
  *описовим* та *лаконісним*. В ідеалі, воно не повинне займати більш як
  *50 символів*. Воно повинне починатись з великої літери і бути написаним в
  теперішньому часі. В кінці повідомлення не варто ставити крапку, адже воно,
  в деякій міріє *назвою* коміту:

  ```shell
  # добре - теперішній час, з великої літери, менш ніж 50 символів
  Відмічаємо старі записи застарілими для попередження помилок при очищенні

  # погано
  Виправили повідомлення про застарілі ActiveModel::Errors Коли AR були
  икористані всередині Rails.
  ```

* Після цього слід пропустити один рядок та дати повний опис внесених змін.
  Воно повинне бути обмеженим в *72 символи* та пояснювати *для чого* були
  потрібні внесені зміни, *як* ці зміни виріщують проблему та які *побічні ефекти* це може мати.

  Також в опис слід включити посилання на пов’язані ресурси (напр. посилання на
  відповідну сторінку помилку в баг-трекері):

  ```shell
  Короткий (50 літер або менше) опис змін.

  Більш детальний роз’яснювальний текст, при потребі. Обмежений
  72 символами. Часом, перший рядок опису коміту трактується як
  тема електронного листа, а решту тексту в якості тіла.
  Порожня лінія-роздільник, що розділяє "тему" та "тіло" необхідна,
  (якщо тільки ви не пропускаєте "тіло" зовсім), інакше інструменти rebase
  можуть помилково сприйняти їх як однин рядок.

  Наступні параграфи повинні розділятись порожніми рядкоми.

  - Пункти списку можна використовувати також

  - Використовуйте ненумеровані списки з дефісом, крапкою або зірочкою,
    в якості роздільника, відділяючи їх від тексту пробілом.
    Між пунктами списку має бути порожній рядок.

  Сирець: http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html
  ```

  Зрештою, коли писатимете повідомлення до коміту, подумайте про те, що б
  могло вам знадобитись через рік після коміту.

* Якщо *коміт A* залежить від іншого *коміту Б*, то цю залежність слід вказати
  в повідомленні до *коміту A*. Використовуйте хеші комітів, щоб посилатись н
  них.

  Аналогічно, якщо *Коміт A* вирішує проблему в допущену в *коміті Б*, це слід
  згадати в повідомленні до *коміту А*.

* Якщо коміт потрібно додати до іншого коміту, використовуйте прапорці
  `--squash` та `--fixup`:

  ```shell
  $ git commit --squash f387cab2
  ```

  *(Порада: Використовуйте прапорець `--autosquash` для переміщення ваших
  змін. При цьому відмічені коміти будуть злиті автоматично.)*

## Злиття

* **Не переписуйте опубліковану історію.** Історія репозиторію дуже важлива,
  адже вона дозволяє зрозуміти *що насправді відбулось*. Зміна опублікованої
  історії може мати обернутись великими проблемами для всіх, хто працює з цим
  репозиторієм.

* Однак, бувають випадки, коли переписування історії цілком обґрунтоване.
  Це випадки коли:

  * Ви одні працюєте над поточною гілкою і ваш код не проходить рев’ю.

  * Вам потрібно "прибрати" в своїй гілці (напр. об’єднати кілька комітів)
    та/або перемістити зміни в "master", щоб пізніше їх злити.

  Це означає, *ніколи не переписуйте гілку "master"* або інші спеціальні гілки
  (напр. ті які використовуються на продакшені, або  CI-серверами).

* Зберігайте історію *чистою* та *простою*. *Перед злиттям* вашої гілки:

    1. Переконайтесь, що зміни відповідають цьому керівництву, якщо вони не
       відповідають, то виправте це (об’єднайте коміти, змініть їх порядок,
       переформулюйте їх повідомленя та ніше.)

    2. Перемістіть зміни в гілку, в яку їх потрібно внести:

       ```shell
       [my-branch] $ git fetch
       [my-branch] $ git rebase origin/master
       # тільки після цього об’єднуйте
       ```

       Ці команди створюють гілку, яку можна приєднати в кінець "master", що
       значно спрощує історію комітів.

       *(Примітка: Цей спосіб краще використовувати в проектах з відносно
       короткими гілками. В іншому випадку краще було б просто провести злиття
       гілок.)*

* Якщо ваша гілка включає більше як один коміт, не варто проводити автоматичне зливання (з fast-forward):

  ```shell
  # добре - коміт зі злиттям буде створено
  $ git merge --no-ff my-branch

  # погано
  $ git merge my-branch
  ```

## Інше.

* Є багато різних способів організації командної роботи і в кожного є свої
  переваги та недоліки.
  Який спосіб підійде саме вам, залежить від команди, проекту і процесу
  розробки.

  Це означає, що найважливіше — *обрати* спосіб організації та дотримуватись
  його.

* *Будьте послідовними.* Це стосується не лише способу організації, але й
  таких речей, як повідомлення комітів, назви гілок та тегів. Дотримуйтесь
  обраного стилю у всьому репозиторії, оскільки це покращує розуміння того, що
  відбувається в історії, в повідомленнях комітів та в іншому.

* *Тестуйте перед пушем.* Не надсилайте в репозиторій напівготові зміни.

* Використовуйте [анотовані мітки](http://git-scm.com/book/en/v2/Git-Basics-Tagging#Annotated-Tags)
  щоб відмітити релізи або інші важливі точки в історії змін проекту.
  Надавайте перевагу [підписаним міткам](http://git-scm.com/book/en/v2/Git-Basics-Tagging#Lightweight-Tags) для особистого використання, як от в якості
  закладок для комітів.

* Тримайте ваш локальний *та* віддалений репозиторій в хорошому стані з
  допомогою команд:

  * [`git-gc(1)`](http://git-scm.com/docs/git-gc)
  * [`git-prune(1)`](http://git-scm.com/docs/git-prune)
  * [`git-fsck(1)`](http://git-scm.com/docs/git-fsck)

# Ліцензія

![cc license](http://i.creativecommons.org/l/by/4.0/88x31.png)

Ця робота ліцензується під Creative Commons Attribution 4.0
International license.

# Авторcьке право

Agis Anastasopoulos / [@agisanast](https://twitter.com/agisanast) / http://agis.io

# Переклад

Денис Довгань (Denys Dovhan) / [@denysdovhan](https://twitter.com/denysdovhan) / [www.denysdovhan.com](http://www.denysdovhan.com)

